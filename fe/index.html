<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Selector with Vue</title>
        <script src="vue.js"></script>
        <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        svg {
    overflow: scroll;
}
        .node { margin: 10px; border: 1px solid black; padding: 10px; display: inline-block; cursor: pointer; }
        .field { margin-top: 5px; }
        div.container {
    width: 100%;    /* Or a fixed size like 800px */
    height: auto;
    overflow: scroll; 
}
.context-menu {
    position: absolute;
    background-color: #f5f5f5;
    border: 1px solid #ccc;
    padding: 10px;
    box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    cursor: pointer;
}

.context-menu p {
    margin: 0;
    padding: 5px;
}
/* d3.js workaround for text */
text {
    pointer-events: none;
}

    </style>
</head>
<body>


<div id="app">
    <!-- Left Panel -->
    <div style="float: left; width: 20%;">
        <button @click="toggleLayout">Toggle Layout</button>
        <h3>Available Nodes:</h3>
    <div v-for="node in Object.keys(nodesData)" class="node" @click="setActiveNode(node)">
            {{ node }}
        </div>
    </div>

    <!-- Center Panel -->
    <div style="float: left; width: 70%;">
        <svg width="20000" height="2000" overflow="scroll"></svg>

    </div>
</div>

<!-- Some basic styles for visibility -->
<style>
    .node {
        cursor: pointer;
        background-color: #e6e6e6;
        padding: 10px;
        margin: 5px;
    }
</style>


<script>
new Vue({
    el: '#app',
    data: {
        
        layoutOrientation: 'horizontal',
        //layoutOrientation: 'vertical',
        nodesData: {},  // Loaded from API
        activeNode: null,
        graph: {
            nodes: [],
            links: []
        },
        fieldOrder: [],
    },
    methods: {
        
        toggleLayout() {
        console.log(this.layoutOrientation )
        if (this.layoutOrientation === 'horizontal') {
            this.layoutOrientation = 'vertical';
        } else {
            this.layoutOrientation = 'horizontal';
        }

        this.drawGraph();
    },
        fetchNodes() {
            fetch("api/list-nodes?format=json&groupby=node")
                .then(response => response.json())
                .then(data => {
                    this.nodesData = data;
                });
        },
        setActiveNode(node) {
    this.graph.nodes = [];
    this.graph.links = [];

    // Create central node for the selected node
    this.activeNode = {
        type: 'node',
        name: node,
        slot: 1,
        level: 0
    };

    this.graph.nodes.push(this.activeNode);

    // Use fieldOrder to add fields to graph.nodes with type 'field'
    this.nodesData[node].forEach((field, index) => {
        const fieldNode = {
            type: 'field',
            name: field.field,
            slot: index,
            level: 1
        };

        this.graph.nodes.push(fieldNode);
        this.graph.links.push({ source: this.activeNode, target: fieldNode });
    });
    this.drawGraph();

           


        },
drawGraph() {
    const svg = d3.select("svg");
    svg.selectAll("*").remove();

    // Define grid levels
    const slotWidth = 150;
    const slotHeight = 100;
    const gridY_level = [50, 150, 250];
    const gridXSpacing = 100;

    this.graph.nodes.forEach(node => {
        node.fx = node.slot * slotWidth;
        node.fy = gridY_level[node.level];
    })


    const simulation = d3.forceSimulation(this.graph.nodes)
        .force("link", d3.forceLink(this.graph.links).id(d => d.id).distance(80))
        .force("charge", d3.forceManyBody().strength(-1000))
        .force("center", d3.forceCenter(400, 200));

    const links = svg.append("g")
        .selectAll("line")
        .data(this.graph.links)
        .enter().append("line")
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.6);

        const nodes = svg.append("g")
        .selectAll("rect")
        .data(this.graph.nodes)
        .enter().append("rect")
        .attr("width", 120)
        .attr("height", 30)
        .attr("rx", 10)
        .attr("ry", 10)
        .attr("fill", d => d.type === 'node' ? "#69a3b2" : "#d1c4e9")
        .attr("x", d => d.fx - 50)  // Half the width to center
        .attr("y", d => d.fy - 15)  // Half the height to center
        .call(d3.drag()
            .on("start", dragstarted.bind(this))
            .on("drag", dragged.bind(this))
            .on("end", dragended.bind(this)))
        .on('click', (event, d) => {
        if (d.type === 'field') {
            createContextMenu(event, d);
        }
    });

    const labels = svg.append("g")
    .selectAll("text")
    .data(this.graph.nodes)
    .enter().append("text")
    .attr("font-size", "16px")
    .text(d => d.name)
    .attr("text-anchor", "right")
    .attr("x", d => d.fx)
    .attr("y", d => d.fy) 

   



    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        intendedY = d.fy = d.y;
    }

function dragged(event, d) {
    d.fx = event.x;
    d.fy = gridY_level[d.level];  // Always lock the y-position based on the level

    const newSlot = Math.round(d.fx / slotWidth);

    // Check if there's any other node in this newSlot
    const nodeInNewSlot = this.graph.nodes.find(node => node.slot === newSlot &&  node.level === d.level && node !== d);

    if (nodeInNewSlot) {
        // Swap their slots
        nodeInNewSlot.slot = d.slot;
        d.slot = newSlot;

        // Update their fixed x-positions based on the updated slot positions
        nodeInNewSlot.fx = nodeInNewSlot.slot * slotWidth;
        d.fx = d.slot * slotWidth;
    }
}

    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);

        // Update slot based on final position
        const newSlot = Math.round(d.fx / slotWidth);
        d.slot = newSlot;

        // Set the fixed position based on slot and level
        d.fx = d.slot * slotWidth;
        //d.fy = null
        //Y_level[d.level];
    }

    function removeNode(nodeData) {
    // Remove the node from graph.nodes
    const nodeIndex = this.graph.nodes.indexOf(nodeData);
    if (nodeIndex > -1) {
        this.graph.nodes.splice(nodeIndex, 1);
    }

    // Remove associated links from graph.links
    const linksToRemove = this.graph.links.filter(link => link.source === nodeData || link.target === nodeData);
    linksToRemove.forEach(link => {
        const linkIndex = this.graph.links.indexOf(link);
        if (linkIndex > -1) {
            this.graph.links.splice(linkIndex, 1);
        }
    });

    // Now, redraw the graph or refresh the visualization
    //renderGraph();
    this.drawGraph();
    
}
function openOperatorDialog(nodeData) {
    const div = document.createElement('div');
    div.innerHTML = `
        <label>Enter Operator Details:</label>
        <input type="text" id="operatorInput" />
        <button onclick="handleOperatorSubmit()">OK</button>
    `;

    document.body.appendChild(div);

    // Define the handler for when the dialog is submitted
    window.handleOperatorSubmit = function() {
        const inputValue = document.getElementById('operatorInput').value;
        if (inputValue) {
            // Make the API call or any other logic you need with the inputValue
            // Example: createOperator(nodeData, inputValue);
        }

        // Remove the dialog after submission
        document.body.removeChild(div);
    }
}

function openLinkDialog(nodeData) {
    const div = document.createElement('div');
    div.innerHTML = `
        <label>Enter Link Details:</label>
        <input type="text" id="linkInput" />
        <button onclick="handleLinkSubmit()">OK</button>
    `;

    document.body.appendChild(div);

    // Define the handler for when the dialog is submitted
    window.handleLinkSubmit = function() {
        const inputValue = document.getElementById('linkInput').value;
        if (inputValue) {
            // Make the API call or any other logic you need with the inputValue
            // Example: createLink(nodeData, inputValue);
        }

        // Remove the dialog after submission
        document.body.removeChild(div);
    }
}

    function handleContextMenuClick(option, nodeData) {
    console.log('joi', option)
    console.log('eee', nodeData)
    switch (option) {
        case 'Remove':
            console.log("remove")
            removeNode(nodeData);
            break;
        case 'Operator':
             console.log("operator")
            openOperatorDialog(nodeData);
            break;
        case 'Link':
            console.log("link")
            openLinkDialog(nodeData);
            break;
    }
}

function createContextMenu(event, d) {
    // Remove any existing context menu
    d3.selectAll('.context-menu').remove();

    // Create a div for our context menu
    const menu = d3.select('body')
        .append('div')
        .attr('class', 'context-menu')
        .style('left', `${event.pageX}px`)
        .style('top', `${event.pageY}px`)
        .style('zIndex', '1000');  // Set a high zIndex value

    const options = ['Remove', 'Operator', 'Link'];

    // Append our three options to the menu
    menu.selectAll('p')
    .data(options)
    .enter()
    .append('p')
    .text(d => d)
    .on('click', function() { // Don't pass in option here
        const selectedOption = d3.select(this).text();  // Get the text of the clicked option
        handleContextMenuClick(selectedOption, d);  
        d3.selectAll('.context-menu').remove();
    });
}

removeNode = removeNode.bind(this);
handleContextMenuClick = handleContextMenuClick.bind(this);
createContextMenu = createContextMenu.bind(this);


    simulation.on("tick", () => {
        links
            .attr("x1", d => d.source.x + 50)
            .attr("y1", d => d.source.y + 15)
            .attr("x2", d => d.target.x + 50)
            .attr("y2", d => d.target.y + 15);

        nodes
            .attr("x", d => d.x)
            .attr("y", d => d.y);

        labels
            .attr("x", d => d.x + 5)
            .attr("y", d => d.y + 20);
    });
}


    },
    mounted() {
        this.fetchNodes();
    }
});

</script>
</body>
</html>

