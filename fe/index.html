<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Data Selector with Vue</title>
        <script src="vue.js"></script>
        <script src="https://d3js.org/d3.v6.min.js"></script>
        <style>
            svg {
                overflow: scroll;
            }
            .node {
                margin: 10px;
                border: 1px solid black;
                padding: 10px;
                display: inline-block;
                cursor: pointer;
            }
            .field {
                margin-top: 5px;
            }

            div.container {
                width: 100%;
                /* Or a fixed size like 800px */
                height: auto;
                overflow: scroll;
            }

            .context-menu {
                position: absolute;
                background-color: #f5f5f5;
                border: 1px solid #ccc;
                padding: 10px;
                box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
                z-index: 1000;
                cursor: pointer;
            }

            /* d3.js workaround for text */
            text {
                pointer-events: none;
            }

            #app {
                position: relative;
                /* Important for positioning the row count */
                display: grid;
                grid-template-columns: 20% 1fr;
                /* left_panel takes 20%, center takes the remaining width */
                grid-template-rows: auto auto;
                /* Two rows: one for top and another for center */
                grid-template-areas:
                    "left_panel center_top right_top"
                    "left_panel center_center .";
            }

            .left_panel {
                grid-area: left_panel;
            }

            .center_top {
                grid-area: center_top;
            }

            .right_top {
                grid-area: right_top;
            }

            .center_center {
                grid-area: center_center;
            }

            /* For the row count */
            .row_count {
                position: absolute;
                top: 0;
                right: 0;
                padding: 24px;
                z-index: 10;
                /* To ensure it stays on top */
            }
            .download_buttons {
                position: absolute;
                top: 50px; /* this should be the height of your row_count + some padding */
                right: 0;
                z-index: 10; /* To ensure it stays on top */
                display: flex;
                flex-direction: column;
                gap: 10px; /* Space between the buttons */
                padding: 0 24px;
            }
        </style>
    </head>
    <body>
        <div id="app">
            <!-- Left Panel -->
            <div class="left_panel">
                <button @click="copyDataUrl">Copy Data URL</button>
                <!-- Search input -->
                <input v-model="searchQuery" placeholder="Search for nodes..." />
                <h3>Available Nodes:</h3>

                <div v-for="node in filteredNodes" class="node" @click="setActiveNode(node)">
                    <!-- {{ node }} below is certain context only TODO-->
                    {{ node.startsWith('domain.') ? node.replace('domain.', '') : node }}
                </div>
            </div>

            <!-- Center Top Panel -->
            <div class="center_top">
                <svg width="20000" height="400" overflow="scroll"></svg>
            </div>

            <!-- Right Top Panel -->
            <!-- We'll keep this empty since the Row Count has its own separate section -->

            <!-- Center Center Panel -->
            <div class="center_center" style="width: 100%; overflow-x: auto; margin-top: 2em;">
                <h3 v-if="result && result.length">
                    {{ result.length >= 100 ? 'First ' : '' }}{{ result.length }} Results:
                </h3>
                <table v-if="result && result.length" border="1" cellspacing="0" cellpadding="5">
                    <thead>
                        <tr>
                            <th v-for="header in Object.keys(result[0])">{{ header }}</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr v-for="row in result">
                            <td v-for="value in Object.values(row)">{{ value }}</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Row Count -->
            <div class="row_count">
                Row Count: {{ currentRowCount }}
            </div>

            <!-- Download buttons -->
            <div class="download_buttons">
                <button @click="downloadAs('csv')">Download as CSV</button>
                <button @click="downloadAs('json')">Download as JSON</button>
             <!-- <button @click="downloadResults">Download</button> -->
             <!-- <button @click="fetchPreview">Preview</button> -->
            </div>
        </div>

        <!-- Some basic styles for visibility -->
        <style>
            .node {
                cursor: pointer;
                background-color: #e6e6e6;
                padding: 10px;
                margin: 5px;
            }
        </style>

        <script>
            new Vue({
                el: '#app',
                data: {
                    layoutOrientation: 'horizontal',
                    searchQuery: '',
                    nodesData: {}, // Loaded from API
                    activeNode: null,
                    _internalRowCount: 0,
                    type_operators: {},
                    graph: {
                        nodes: [],
                        links: []
                    },
                    fieldOrder: [],
                    result: [],
                },
                computed: {
                    filteredNodes() {
                        // If there's no search query, return all nodes
                        if (!this.searchQuery) {
                            return Object.keys(this.nodesData);
                        }
                        const query = this.searchQuery.toLowerCase();
                        // Filter nodes based on the search query
                        return Object.keys(this.nodesData).filter(node => node.toLowerCase().includes(query));
                    },
                    currentRowCount() {
                        return (this.result && this.result.length != 100 && this.result.length > 0) ? this.result.length : this._internalRowCount;
                    }
                },
                watch: {
                    'graph.nodes': {
                        handler() {
                            this.fetchPreview();
                        },
                        deep: true // Ensure the watcher triggers on deep/nested changes
                    }
                },
                methods: {
                    fetchPreview() {
                        fetch("api/gen/?" + this.generateQueryString() + "&limit=100")
                            .then(response => response.json())
                            .then(data => {
                                this.result = data;
                            });
                    },
                    downloadAs(format) {
                        const downloadURL = "api/gen/?" + this.generateQueryString() + "&format=" + format;
                        window.location.href = downloadURL;
                    },
                    downloadResults() {
                        fetch("api/gen/?" + this.generateQueryString())
                            .then(response => response.json())
                            .then(data => {
                                this.result = data;
                            });
                    },
                    generateQueryString() {
                        let queryString = "dn=" + encodeURIComponent(this.activeNode.name);

                        // Map the field nodes to the desired string format and sort by slot
                        let fieldStrings = this.graph.nodes
                            .filter(node => node.type === "field")
                            .sort((a, b) => a.slot - b.slot)
                            .map(field => `field=${encodeURIComponent(field.parent + '.' + field.name)}`);

                        // Filter the operator nodes that are of type "filter", sort by slot,
                        // and then map to the desired string format
                        let filterStrings = this.graph.nodes
                            .filter(node => node.type === "operator" && node.operator_type === "filter")
                            .sort((a, b) => a.slot - b.slot)
                            .map(filter =>
                                `filter=${encodeURIComponent(filter.operator + ':' + filter.parent + '.' + filter.field_name + ':' + filter.operator_input)}`
                            );

                        //TOHERE
                        let linkStrings = this.graph.nodes
                            .filter(node => node.type === "operator" && node.operator_type === "link")
                            .sort((a, b) => a.slot - b.slot)
                            .map(link =>
                                `link=${encodeURIComponent(link.parent + '.' + link.field_name + ':' + link.operator + '.' + link.operator_input)}`
                            );


                        // Filter the operator nodes that are of type "orderby", sort by slot,
                        // and then map to the desired string format
                        let orderByStrings = this.graph.nodes
                            .filter(node => node.type === "operator" && node.operator_type === "orderby")
                            .sort((a, b) => a.slot - b.slot)
                            .map(orderBy =>
                                `orderby=${orderBy.operator}:${encodeURIComponent(orderBy.parent + '.' + orderBy.field_name)}`
                            );

                        // If there are fieldStrings, filterStrings, or orderByStrings, prepend them with an "&"
                        if (fieldStrings.length > 0) {
                            queryString += "&" + fieldStrings.join("&");
                        }

                        if (filterStrings.length > 0) {
                            queryString += "&" + filterStrings.join("&");
                        }

                        if (orderByStrings.length > 0) {
                            queryString += "&" + orderByStrings.join("&");
                        }
                        if (linkStrings.length > 0) {
                            queryString += "&" + linkStrings.join("&");
                        }
                        return queryString;
                    },
                    copyDataUrl() {

                        const url = `${window.location.protocol}//${window.location.host}/api/gen/?${this.generateQueryString()}`;
                        console.log(url);
                        const textarea = document.createElement('textarea');
                        textarea.textContent = url;
                        textarea.style.position = 'fixed';  // Prevent scrolling to bottom of page in MS Edge.
                        document.body.appendChild(textarea);
                        textarea.select();
                        try {
                            document.execCommand('copy');
                            alert('URL copied to clipboard');
                        } catch (err) {
                            console.error('Could not copy URL', err);
                        }
                        document.body.removeChild(textarea);

                        this.drawGraph();
                    },
                    fetchResults() {
                        fetch("api/gen/?" + this.generateQueryString())
                            .then(response => response.json())
                            .then(data => {
                                this.result = data;
                            });
                    },
                    fetchNodes() {
                        fetch("api/list-nodes?format=json&groupby=node")
                            .then(response => response.json())
                            .then(data => {
                                this.nodesData = data;
                            });
                    },
                    fetchTypeOperators() {
                        fetch("api/sm-query-options/")
                            .then(response => response.json())
                            .then(data => {
                                this.type_operators = data["type_operators"];
                            });
                    },
                    findNodeAndSetRowCount(node) {
                        let foundNode = null;

                        for (let key in this.nodesData) {
                            foundNode = this.nodesData[key].find(entry => entry.node === node);

                            if (foundNode) {
                                break;
                            }
                        }
                        this.result = [];
                        this._internalRowCount = foundNode ? foundNode.row_count : 0;
                    },
                    setActiveNode(node) {
                        this.findNodeAndSetRowCount(node);
                        this.graph.nodes = [];
                        this.graph.links = [];

                        this.activeNode = {
                            type: 'node',
                            main: true,
                            name: node,
                            slot: 1,
                            level: 0
                        };

                        this.graph.nodes.push(this.activeNode);
                        this.nodesData[node].forEach((field, index) => {
                            const fieldNode = {
                                type: 'field',
                                name: field.field,
                                slot: index,
                                level: 1,
                                parent: field.node,
                                field_type: field.field_type
                            };

                            this.graph.nodes.push(fieldNode);
                            this.graph.links.push({
                                source: this.activeNode,
                                target: fieldNode
                            });
                        });
                        this.drawGraph();
                    },
                    drawGraph() {
                        const svg = d3.select("svg");
                        svg.selectAll("*").remove();

                        // Define grid levels
                        const slotWidth = 150;
                        const slotHeight = 100;
                        const gridY_level = [50, 150, 250];
                        const gridXSpacing = 100;

                        this.graph.nodes.forEach(node => {
                            node.fx = node.slot * slotWidth;
                            node.fy = gridY_level[node.level];
                        })

                        const simulation = d3.forceSimulation(this.graph.nodes)
                            .force("link", d3.forceLink(this.graph.links).id(d => d.id).distance(80))
                            .force("charge", d3.forceManyBody().strength(-1000))
                            .force("center", d3.forceCenter(400, 200));

                        const links = svg.append("g")
                            .selectAll("line")
                            .data(this.graph.links)
                            .enter().append("line")
                            .attr("stroke", "#999")
                            .attr("stroke-opacity", 0.6);

                        const nodes = svg.append("g")
                            .selectAll("rect")
                            .data(this.graph.nodes)
                            .enter().append("rect")
                            .attr("width", 120)
                            .attr("height", 30)
                            .attr("rx", 10)
                            .attr("ry", 10)
                            .attr("fill", d => {
                                if (d.type === 'node') return "#69a3b2";
                                if (d.type === 'field') return "#d1c4e9";
                                if (d.type === 'operator') return "#d4af37"; // Adjusted color for operator
                                if (d.type === 'link') return "#c15c22"; // Adjusted color for link
                                return "gray"; // Default color in case none of the types matc

                            }).attr("x", d => d.fx - 50) // Half the width to center
                            .attr("y", d => d.fy - 15) // Half the height to center
                            .call(d3.drag()
                                .on("start", dragstarted.bind(this))
                                .on("drag", dragged.bind(this))
                                .on("end", dragended.bind(this)))
                            .on('click', (event, d) => {
                                if (d.type === 'field' || d.type === 'operator') {
                                    createContextMenu(event, d);
                                }
                            });

                        const labels = svg.append("g")
                            .selectAll("text")
                            .data(this.graph.nodes)
                            .enter().append("text")
                            .attr("font-size", "16px")
                            .text(d => d.name)
                            .attr("text-anchor", "right")
                            .attr("x", d => d.fx)
                            .attr("y", d => d.fy)

                        function dragstarted(event, d) {
                            if (!event.active) simulation.alphaTarget(0.3).restart();
                            d.fx = d.x;
                            intendedY = d.fy = d.y;
                        }

                        function dragged(event, d) {
                            d.fx = event.x;
                            d.fy = gridY_level[d.level]; // Always lock the y-position based on the level

                            const newSlot = Math.round(d.fx / slotWidth);

                            // Check if there's any other node in this newSlot
                            const nodeInNewSlot = this.graph.nodes.find(node => node.slot === newSlot && node
                                .level === d.level && node !== d);

                            if (nodeInNewSlot) {
                                // Swap their slots
                                nodeInNewSlot.slot = d.slot;
                                d.slot = newSlot;

                                // Update their fixed x-positions based on the updated slot positions
                                nodeInNewSlot.fx = nodeInNewSlot.slot * slotWidth;
                                d.fx = d.slot * slotWidth;
                            }
                        }

                        function dragended(event, d) {
                            if (!event.active) simulation.alphaTarget(0);

                            // Update slot based on final position
                            const newSlot = Math.round(d.fx / slotWidth);
                            d.slot = newSlot;

                            // Set the fixed position based on slot and level
                            d.fx = d.slot * slotWidth;
                        }

                        function removeOperatorNode(nodeData) {
                            if (nodeData.type !== "operator") {
                                console.error("Node is not of type 'operator'");
                                return;
                            }

                            // Remove the node from graph.nodes
                            const nodeIndex = this.graph.nodes.indexOf(nodeData);
                            if (nodeIndex > -1) {
                                this.graph.nodes.splice(nodeIndex, 1);
                            }

                            // Remove all links associated with this node
                            const linksToRemove = this.graph.links.filter(link => {
                                return link.source === nodeData || link.target === nodeData;
                            });

                            linksToRemove.forEach(link => {
                                const linkIndex = this.graph.links.indexOf(link);
                                if (linkIndex > -1) {
                                    this.graph.links.splice(linkIndex, 1);
                                }
                            });

                            this.drawGraph();
                        }

                        function removeNode(nodeData, event) {

                            const removedNodeSlot = nodeData.slot;

                            const nodeIndex = this.graph.nodes.indexOf(nodeData);
                            if (nodeIndex > -1) {
                                this.graph.nodes.splice(nodeIndex, 1);
                            }

                            const linksToRemove = this.graph.links.filter(link => {
                                return link.source === nodeData || link.target === nodeData;
                            });

                            const operatorNodesToRemove = [];

                            linksToRemove.forEach(link => {
                                // Store the operator nodes that are associated with these links for removal
                                if (link.source.type === 'operator' && operatorNodesToRemove.indexOf(link
                                        .source) === -1) {
                                    operatorNodesToRemove.push(link.source);
                                } else if (link.target.type === 'operator' && operatorNodesToRemove.indexOf(
                                        link.target) === -1) {
                                    operatorNodesToRemove.push(link.target);
                                }

                                // Remove the link itself
                                const linkIndex = this.graph.links.indexOf(link);
                                if (linkIndex > -1) {
                                    this.graph.links.splice(linkIndex, 1);
                                }
                            });

                            // Now, let's remove the operator nodes that were linked to the nodeData
                            operatorNodesToRemove.forEach(operatorNode => {
                                const nodeIndex = this.graph.nodes.indexOf(operatorNode);
                                if (nodeIndex > -1) {
                                    this.graph.nodes.splice(nodeIndex, 1);
                                }
                            });

                            // Adjust the slot values of all nodes that come after the removed node
                            this.graph.nodes.forEach(node => {
                                if (node.type === "field" && node.slot > removedNodeSlot) {
                                    node.slot -= 1;
                                }
                            });

                            // Let the drawing function handle positioning and rendering
                            this.drawGraph();
                        }
                        function openOrderByDialog(nodeData, event) {
                            const div = document.createElement('div');
                            const currentContext = this;

                            div.style.position = 'absolute';
                            div.style.left = `${event.pageX}px`;
                            div.style.top = `${event.pageY}px`;
                            div.style.zIndex = '1000';

                            const optionsArray = ['asc', 'desc'];
                            let optionsHTML = optionsArray.map(option =>
                                `<option value="${option}">${option}</option>`).join('');

                            div.innerHTML = `
                                <label>Order By:</label>
                                <select id="orderByOption">${optionsHTML}</select>
                                
                                <button onclick="submitHandlerOrderBy()">OK</button>
                            `;

                            document.body.appendChild(div);

                            const submitHandlerOrderBy = () => {
                                const selectedOption = document.getElementById('orderByOption').value;

                                const slotIsTaken = currentContext.graph.nodes.some(node => node.slot ===
                                    nodeData.slot && node.type === 'operator');
                                if (slotIsTaken) {
                                    currentContext.graph.nodes.forEach(node => {
                                        if (node.slot >= nodeData.slot && node.type === 'operator') {
                                            node.slot += 1;
                                        }
                                    });
                                }

                                const orderByNode = {
                                    type: 'operator',
                                    name: `Order by: ${selectedOption}`,
                                    slot: nodeData.slot,
                                    level: 2,
                                    parent: nodeData.parent,
                                    field_name: nodeData.name,
                                    operator_type: "orderby",
                                    operator: selectedOption,
                                    operator_input: null  // No operator_input for orderby
                                };

                                currentContext.graph.nodes.push(orderByNode);
                                currentContext.graph.links.push({
                                    source: nodeData,
                                    target: orderByNode
                                });

                                currentContext.drawGraph();
                                document.body.removeChild(div);
                            };

                            window.submitHandlerOrderBy = submitHandlerOrderBy;
                        }

                        function openFilterDialog(nodeData, event) {
                            const div = document.createElement('div');
                            const currentContext = this;

                            div.style.position = 'absolute';
                            div.style.left = `${event.pageX}px`;
                            div.style.top = `${event.pageY}px`;
                            div.style.zIndex = '1000';

                            const optionsArray = this.type_operators[nodeData["field_type"]];
                            console.log(nodeData["field_type"])
                            let optionsHTML = optionsArray.map(option =>
                                `<option value="${option}">${option}</option>`).join('');

                            div.innerHTML = `
                                <label>Filter Type:</label>
                                <select id="filterOption">${optionsHTML}</select>
                                
                                <label>Enter Filter Details:</label>
                                <input type="text" id="filterInput" />
                                
                                <button onclick="submitHandler()">OK</button>
                            `;

                            document.body.appendChild(div);

                            const submitHandler = () => {
                                const selectedOption = document.getElementById('filterOption').value;
                                const inputValue = document.getElementById('filterInput').value;

                                const slotIsTaken = currentContext.graph.nodes.some(node => node.slot ===
                                    nodeData.slot && node.type === 'operator');
                                if (slotIsTaken) {
                                    currentContext.graph.nodes.forEach(node => {
                                        if (node.slot >= nodeData.slot && node.type === 'operator') {
                                            node.slot += 1;
                                        }
                                    });
                                }
                                if (inputValue) {
                                    const operatorNode = {
                                        type: 'operator',
                                        name: selectedOption + ": " + inputValue,
                                        slot: nodeData.slot,
                                        level: 2,
                                        parent: nodeData.parent,
                                        field_name: nodeData.name,
                                        operator_type: "filter",
                                        operator: selectedOption,
                                        operator_input: inputValue
                                    };

                                    currentContext.graph.nodes.push(operatorNode);
                                    currentContext.graph.links.push({
                                        source: nodeData,
                                        target: operatorNode
                                    });
                                    currentContext.drawGraph();
                                }
                                document.body.removeChild(div);
                            };
                            window.submitHandler = submitHandler;
                        }


                        async function openLinkDialog(nodeData) {
                            // Create a dialog
                            const div = document.createElement('div');
                            div.style.position = 'absolute';
                            div.style.left = `${event.pageX}px`; // Position horizontally where the mouse click happened
                            div.style.top = `${event.pageY}px`;  // Position vertically where the mouse click happened
                            div.style.zIndex = '1000';
                            const currentContext = this;

                            // Make the API call to get the possible fields for linking
                            const response = await fetch(`http://127.0.0.1:8080/api/link-possible/${nodeData.parent}/${nodeData.name}?groupby=node`);
                            const data = await response.json();

                            // Create HTML for dropdowns
                            let dropdownOptions1 = Object.keys(data).map(node =>
                                `<option value="${node}">${node}</option>`).join('');

                            // Populate the first dropdown and also populate the second dropdown based on the first entry by default.
                            let firstNode = Object.keys(data)[0];
                            let dropdownOptions2 = data[firstNode].map(field =>
                                    `<option value="${field.field}">${field.field}</option>`).join('');

                            div.innerHTML = `
                                <label>Select Node:</label>
                                <select id="linkNode" onchange="populateSecondDropdown()">${dropdownOptions1}</select>

                                <label>Select Field:</label>
                                <select id="linkField">${dropdownOptions2}</select>

                                <button onclick="handleLinkSubmit()">OK</button>
                            `;

                            // Append to body
                            document.body.appendChild(div);

                            window.populateSecondDropdown = function() {
                                const selectedNode = document.getElementById('linkNode').value;
                                const fields = data[selectedNode];
                                dropdownOptions2 = fields.map(field => 
                                    `<option value="${field.field}">${field.field}</option>`).join('');
                                document.getElementById('linkField').innerHTML = dropdownOptions2;
                            }

                            window.handleLinkSubmit = function() {
                                const selectedNode = document.getElementById('linkNode').value;
                                const selectedField = document.getElementById('linkField').value;

                                let highestNodeSlot = Math.max(...currentContext.graph.nodes.filter(item => item.type === 'node').map(n => n.slot), 0);
                                let highestFieldSlot = Math.max(...currentContext.graph.nodes.filter(item => item.type === 'field').map(n => n.slot), 0);

                                if (selectedNode && selectedField) {
                                    const operatorNode = {
                                        type: 'operator',
                                        name: `${selectedNode}: ${selectedField}`,
                                        slot: highestFieldSlot,
                                        level: 2,
                                        parent: nodeData.parent,
                                        field_name: nodeData.name,
                                        operator_type: "link",
                                        operator: selectedNode,
                                        operator_input: selectedField
                                    };
                                    currentContext.graph.nodes.push(operatorNode);
                                    currentContext.graph.links.push({
                                        source: nodeData,
                                        target: operatorNode
                                    });


                                    // Add the selected node to this.graph.nodes
                                    const newNode = {
                                        type: 'node',
                                        name: selectedNode,
                                        main: false,
                                        slot: highestFieldSlot + 1,
                                        level: 0
                                    };
                                    currentContext.graph.nodes.push(newNode);
                                    currentContext.nodesData[selectedNode].forEach((field, index) => {
                                        const fieldNode = {
                                            type: 'field',
                                            name: field.field,
                                            slot: highestFieldSlot + 1 + index,
                                            level: 1,
                                            parent: field.node,
                                            field_type: field.field_type
                                        };
                                        currentContext.graph.nodes.push(fieldNode);
                                        currentContext.graph.links.push({
                                            source: newNode,
                                            target: fieldNode
                                        });

                                                // Find the selected field node object from currentContext.graph.nodes
                                        const selectedFieldNode = currentContext.graph.nodes.find(
                                            node => node.type === 'field' && node.name === selectedField && node.parent === selectedNode
                                        );

                                        if (selectedFieldNode) {
                                            // Create a new link from the operator to the selected field
                                            const newLink = {
                                                source: operatorNode,
                                                target: selectedFieldNode
                                            };

                                            // Add this link to currentContext.graph.links
                                            currentContext.graph.links.push(newLink);
                                        }
                                    });

                                    currentContext.drawGraph(); // Assuming you have a method like this to update your graph
                                }

                                // Remove the dialog after submission
                                document.body.removeChild(div);
                            }
                        }


                        function handleContextMenuClick(selectedOption, d, event) {
                            console.log("hanlde context")
                            if (d.type === "field") {
                                switch (selectedOption) {
                                    case 'Remove':
                                        removeNode(d, event);
                                        break;
                                    case 'Filter':
                                        openFilterDialog(d, event);
                                        break;
                                    case 'Orderby':
                                        openOrderByDialog(d, event);
                                        break;
                                    case 'Link':
                                        openLinkDialog(d, event); // Assuming you have a function for this.
                                        break;
                                    default:
                                        break;
                                }
                            } else if (d.type === "operator") {
                                switch (selectedOption) {
                                    case 'Remove':
                                        removeOperatorNode(d, event);
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }

                        function createContextMenu(event, d) {
                            // Remove any existing context menu
                            d3.selectAll('.context-menu').remove();

                            // Create a div for our context menu
                            const menu = d3.select('body')
                                .append('div')
                                .attr('class', 'context-menu')
                                .style('left',
                                    `${event.pageX + 10}px`) // slight offset to not directly open under mouse
                                .style('top', `${event.pageY + 10}px`)
                                .style('zIndex', '1000')
                                .style('border', '1px solid #ccc') // Border around the context menu
                                .style('border-radius', '4px') // Rounded corners
                                .style('background-color', '#f5f5f5') // Background color
                                .style('font-family', 'Arial, sans-serif') // Font 
                                .style('box-shadow', '3px 3px 10px rgba(0, 0, 0, 0.2)'); // Drop shadow
                            if (false) { //(d.type === "field") { Issue that first option get removed
                                menu.append('p')
                                .text(`Type: ${d.field_type}`)
                                .style('margin', '0')
                                .style('padding', '10px 15px')
                                .style('font-weight', 'bold') // Make the type bold for emphasis
                                .style('border-bottom', '1px solid rgba(0, 0, 0, 0.1)'); // Soft border underneath
                            }


                            const contextMenuOptionsMap = {
                                "field": ['Remove', 'Filter', 'Link', 'Orderby'],
                                "operator": ['Remove'],
                            }
                            console.log(d.field_type)
                            const options = contextMenuOptionsMap[d.type] || [];
                            menu.selectAll('p')
                                .data(options)
                                .enter()
                                .append('p')
                                .text(d => d)
                                .style('margin', '0') // Remove margin
                                .style('padding', '10px 15px') // Padding for each option
                                .style('cursor', 'pointer') // Hand cursor on hover
                                .on('mouseover', function () {
                                    d3.select(this).style('background-color',
                                        '#e5e5e5'); // Change background color on hover
                                })
                                .on('mouseout', function () {
                                    d3.select(this).style('background-color',
                                        '#f5f5f5'); // Reset background color
                                })
                                .on('click', function (event) {
                                    const selectedOption = d3.select(this).text();
                                    handleContextMenuClick(selectedOption, d, event);
                                    d3.selectAll('.context-menu').remove();
                                });
                        }

                        removeOperatorNode = removeOperatorNode.bind(this)
                        removeNode = removeNode.bind(this);
                        openLinkDialog = openLinkDialog.bind(this)
                        openFilterDialog = openFilterDialog.bind(this)
                        openOrderByDialog = openOrderByDialog.bind(this)
                        handleContextMenuClick = handleContextMenuClick.bind(this);
                        createContextMenu = createContextMenu.bind(this);


                        simulation.on("tick", () => {
                            links
                                .attr("x1", d => d.source.x + 50)
                                .attr("y1", d => d.source.y + 15)
                                .attr("x2", d => d.target.x + 50)
                                .attr("y2", d => d.target.y + 15);

                            nodes
                                .attr("x", d => d.x)
                                .attr("y", d => d.y);

                            labels
                                .attr("x", d => d.x + 5)
                                .attr("y", d => d.y + 20);
                        });
                    }
                },
                mounted() {
                    this.fetchNodes();
                    this.fetchTypeOperators();
                }
            });
        </script>
    </body>
</html>