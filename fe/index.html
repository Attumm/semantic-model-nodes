<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Selector with Vue</title>
        <script src="vue.js"></script>
        <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        svg {
    overflow: scroll;
}
        .node { margin: 10px; border: 1px solid black; padding: 10px; display: inline-block; cursor: pointer; }
        .field { margin-top: 5px; }
        div.container {
    width: 100%;    /* Or a fixed size like 800px */
    height: auto;
    overflow: scroll; 
}
.context-menu {
    position: absolute;
    background-color: #f5f5f5;
    border: 1px solid #ccc;
    padding: 10px;
    box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    cursor: pointer;
}


/* d3.js workaround for text */
text {
    pointer-events: none;
}

    </style>
</head>
<body>


<div id="app">
    <!-- Left Panel -->
    <div style="float: left; width: 20%;">
        <button @click="toggleLayout">Toggle Layout</button>
        <h3>Available Nodes:</h3>
    <div v-for="node in Object.keys(nodesData)" class="node" @click="setActiveNode(node)">
            {{ node }}
        </div>
    </div>

    <!-- Center Panel -->
    <div style="float: left; width: 70%;">
        <svg width="20000" height="2000" overflow="scroll"></svg>

    </div>

    <!-- information amount -->
    <div style="position: absolute; top: 0; right: 0; padding: 24px;">
        Row Count: {{ current_row_count }}
    </div>
</div>

<!-- Some basic styles for visibility -->
<style>
    .node {
        cursor: pointer;
        background-color: #e6e6e6;
        padding: 10px;
        margin: 5px;
    }
</style>


<script>
new Vue({
    el: '#app',
    data: {
        
        layoutOrientation: 'horizontal',
        //layoutOrientation: 'vertical',
        nodesData: {},  // Loaded from API
        activeNode: null,
        current_row_count: "",
        type_operators: {},
        graph: {
            nodes: [],
            links: []
        },
        fieldOrder: [],
    },
    methods: {
        
        toggleLayout() {
        if (this.layoutOrientation === 'horizontal') {
            this.layoutOrientation = 'vertical';
        } else {
            this.layoutOrientation = 'horizontal';
        }

        this.drawGraph();
    },
        fetchNodes() {
            fetch("api/list-nodes?format=json&groupby=node")
                .then(response => response.json())
                .then(data => {
                    this.nodesData = data;
                });
        },
        fetchTypeOperators() {
            fetch("api/sm-query-options/")
                .then(response => response.json())
                .then(data => {
                    this.type_operators = data["type_operators"];
                });
        },
        findNodeAndSetRowCount(node) {
            let foundNode = null;

            // Loop over  keys in the nodesData object
            for (let key in this.nodesData) {
                // Find the node within the current array
                foundNode = this.nodesData[key].find(entry => entry.node === node);
                
                // If the node is found, break out of the loop for efficiency
                if (foundNode) {
                    break;
                }
            }

            // If the node was found in the nested arrays, update the current_row_count
            if (foundNode) {
                this.current_row_count = foundNode.row_count;
            }
        },

        setActiveNode(node) {
            this.findNodeAndSetRowCount(node);
    this.graph.nodes = [];
    this.graph.links = [];

    // Create central node for the selected node
    this.activeNode = {
        type: 'node',
        name: node,
        slot: 1,
        level: 0
    };

    this.graph.nodes.push(this.activeNode);

    // Use fieldOrder to add fields to graph.nodes with type 'field'
    this.nodesData[node].forEach((field, index) => {
        const fieldNode = {
            type: 'field',
            name: field.field,
            slot: index,
            level: 1,
            parent: field.node,
            field_type: field.field_type
        };

        this.graph.nodes.push(fieldNode);
        this.graph.links.push({ source: this.activeNode, target: fieldNode });
    });
    this.drawGraph();

           


        },
drawGraph() {
    const svg = d3.select("svg");
    svg.selectAll("*").remove();

    // Define grid levels
    const slotWidth = 150;
    const slotHeight = 100;
    const gridY_level = [50, 150, 250];
    const gridXSpacing = 100;

    this.graph.nodes.forEach(node => {
        node.fx = node.slot * slotWidth;
        node.fy = gridY_level[node.level];
    })


    const simulation = d3.forceSimulation(this.graph.nodes)
        .force("link", d3.forceLink(this.graph.links).id(d => d.id).distance(80))
        .force("charge", d3.forceManyBody().strength(-1000))
        .force("center", d3.forceCenter(400, 200));

    const links = svg.append("g")
        .selectAll("line")
        .data(this.graph.links)
        .enter().append("line")
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.6);

        const nodes = svg.append("g")
        .selectAll("rect")
        .data(this.graph.nodes)
        .enter().append("rect")
        .attr("width", 120)
        .attr("height", 30)
        .attr("rx", 10)
        .attr("ry", 10)
        .attr("fill", d => {
    if (d.type === 'node') return "#69a3b2";
    if (d.type === 'field') return "#d1c4e9";
    if (d.type === 'operator') return "#d4af37"; // Adjusted color for operator
    if (d.type === 'link') return "#c15c22";    // Adjusted color for link
    return "gray";  // Default color in case none of the types matc

})   .attr("x", d => d.fx - 50)  // Half the width to center
        .attr("y", d => d.fy - 15)  // Half the height to center
        .call(d3.drag()
            .on("start", dragstarted.bind(this))
            .on("drag", dragged.bind(this))
            .on("end", dragended.bind(this)))
        .on('click', (event, d) => {
        if (d.type === 'field') {
            createContextMenu(event, d);
        }
    });

    const labels = svg.append("g")
    .selectAll("text")
    .data(this.graph.nodes)
    .enter().append("text")
    .attr("font-size", "16px")
    .text(d => d.name)
    .attr("text-anchor", "right")
    .attr("x", d => d.fx)
    .attr("y", d => d.fy) 

    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        intendedY = d.fy = d.y;
    }

function dragged(event, d) {
    d.fx = event.x;
    d.fy = gridY_level[d.level];  // Always lock the y-position based on the level

    const newSlot = Math.round(d.fx / slotWidth);

    // Check if there's any other node in this newSlot
    const nodeInNewSlot = this.graph.nodes.find(node => node.slot === newSlot &&  node.level === d.level && node !== d);

    if (nodeInNewSlot) {
        // Swap their slots
        nodeInNewSlot.slot = d.slot;
        d.slot = newSlot;

        // Update their fixed x-positions based on the updated slot positions
        nodeInNewSlot.fx = nodeInNewSlot.slot * slotWidth;
        d.fx = d.slot * slotWidth;
    }
}

    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);

        // Update slot based on final position
        const newSlot = Math.round(d.fx / slotWidth);
        d.slot = newSlot;

        // Set the fixed position based on slot and level
        d.fx = d.slot * slotWidth;
        //d.fy = null
        //Y_level[d.level];
    }

    function removeNode(nodeData, event) {
        console.log(event)
        console.log(this)

    // Capture the slot of the node to be removed
    const removedNodeSlot = nodeData.slot;

    // Remove the node from graph.nodes
    const nodeIndex = this.graph.nodes.indexOf(nodeData);
    if (nodeIndex > -1) {
        this.graph.nodes.splice(nodeIndex, 1);
    }

const linksToRemove = this.graph.links.filter(link => {
    return link.source === nodeData || link.target === nodeData;
});


    const operatorNodesToRemove = [];

    linksToRemove.forEach(link => {
        // Store the operator nodes that are associated with these links for removal
        if (link.source.type === 'operator' && operatorNodesToRemove.indexOf(link.source) === -1) {
            operatorNodesToRemove.push(link.source);
        } else if (link.target.type === 'operator' && operatorNodesToRemove.indexOf(link.target) === -1) {
            operatorNodesToRemove.push(link.target);
        }

        // Remove the link itself
        const linkIndex = this.graph.links.indexOf(link);
        if (linkIndex > -1) {
            this.graph.links.splice(linkIndex, 1);
        }
    });

    // Now, let's remove the operator nodes that were linked to the nodeData
    operatorNodesToRemove.forEach(operatorNode => {
        const nodeIndex = this.graph.nodes.indexOf(operatorNode);
        if (nodeIndex > -1) {
            this.graph.nodes.splice(nodeIndex, 1);
        }
    });


    // Adjust the slot values of all nodes that come after the removed node
    this.graph.nodes.forEach(node => {
        if (node.type === "field" && node.slot > removedNodeSlot) {
            node.slot -= 1;
        }
    });

    // Let the drawing function handle positioning and rendering
    this.drawGraph();
}   
function openOperatorDialog(nodeData, event) {
    const div = document.createElement('div');
    const currentContext = this;

    div.style.position = 'absolute';
    div.style.left = `${event.pageX}px`;
    div.style.top = `${event.pageY}px`;
    div.style.zIndex = '1000'; 

    const optionsArray = this.type_operators[nodeData["field_type"]];
    console.log(nodeData["field_type"])
    let optionsHTML = optionsArray.map(option => `<option value="${option}">${option}</option>`).join('');

    div.innerHTML = `
        <label>Operator Type:</label>
        <select id="operatorOption">${optionsHTML}</select>
        
        <label>Enter Operator Details:</label>
        <input type="text" id="operatorInput" />
        
        <button onclick="submitHandler()">OK</button>
    `;

    document.body.appendChild(div);

    const submitHandler = () => {
        const selectedOption = document.getElementById('operatorOption').value;
        const inputValue = document.getElementById('operatorInput').value;

        const slotIsTaken = currentContext.graph.nodes.some(node => node.slot === nodeData.slot && node.type === 'operator');
        if (slotIsTaken) {
            currentContext.graph.nodes.forEach(node => {
                if (node.slot >= nodeData.slot && node.type === 'operator') {
                    node.slot += 1;
                }
            });
        }
            
        if (inputValue) {
            const operatorNode = {
                type: 'operator',
                name: selectedOption + ": " + inputValue,
                slot: nodeData.slot,
                level: 2,
                operator_type: "filter",
                operator: selectedOption,
                operator_input: inputValue
            };

            currentContext.graph.nodes.push(operatorNode);
            currentContext.graph.links.push({ source: nodeData, target: operatorNode });

            currentContext.drawGraph();
        }

        document.body.removeChild(div);
    };

    window.submitHandler = submitHandler;
}


function openLinkDialog(nodeData) {
    const div = document.createElement('div');
    div.innerHTML = `
        <label>Enter Link Details:</label>
        <input type="text" id="linkInput" />
        <button onclick="handleLinkSubmit()">OK</button>
    `;

    document.body.appendChild(div);

    // Define the handler for when the dialog is submitted
    window.handleLinkSubmit = function() {
        const inputValue = document.getElementById('linkInput').value;
        if (inputValue) {
            // Make the API call or any other logic you need with the inputValue
            // Example: createLink(nodeData, inputValue);
        }
        // Remove the dialog after submission
        document.body.removeChild(div);
    }
}

    function handleContextMenuClick(option, nodeData, event) {
    console.log(this)
    switch (option) {
        case 'Remove':
            console.log("remove")
            removeNode(nodeData, event);
            break;
        case 'Operator':
             console.log("operator")
             openOperatorDialog(nodeData, event);
            break;
        case 'Link':
            console.log("link")
            openLinkDialog(nodeData, event);
            break;
    }
}

function createContextMenu(event, d) {
    // Remove any existing context menu
    d3.selectAll('.context-menu').remove();

    // Create a div for our context menu
    const menu = d3.select('body')
        .append('div')
        .attr('class', 'context-menu')
        .style('left', `${event.pageX + 10}px`)  // slight offset to not directly open under mouse
        .style('top', `${event.pageY + 10}px`)
        .style('zIndex', '1000')
        .style('border', '1px solid #ccc')    // Border around the context menu
        .style('border-radius', '4px')       // Rounded corners
        .style('background-color', '#f5f5f5')// Background color
        .style('font-family', 'Arial, sans-serif') // Font 
        .style('box-shadow', '3px 3px 10px rgba(0, 0, 0, 0.2)'); // Drop shadow

    const options = ['Remove', 'Operator', 'Link'];

    // Append our three options to the menu
    menu.selectAll('p')
        .data(options)
        .enter()
        .append('p')
        .text(d => d)
        .style('margin', '0')              // Remove margin
        .style('padding', '10px 15px')     // Padding for each option
        .style('cursor', 'pointer')        // Hand cursor on hover
        .on('mouseover', function() {
            d3.select(this).style('background-color', '#e5e5e5');  // Change background color on hover
        })
        .on('mouseout', function() {
            d3.select(this).style('background-color', '#f5f5f5');  // Reset background color
        })
        .on('click', function(event) {
            const selectedOption = d3.select(this).text();
            handleContextMenuClick(selectedOption, d, event);
            d3.selectAll('.context-menu').remove();
        });
}


removeNode = removeNode.bind(this);
openLinkDialog = openLinkDialog.bind(this)
openOperatorDialog = openOperatorDialog.bind(this)
handleContextMenuClick = handleContextMenuClick.bind(this);
createContextMenu = createContextMenu.bind(this);


    simulation.on("tick", () => {
        links
            .attr("x1", d => d.source.x + 50)
            .attr("y1", d => d.source.y + 15)
            .attr("x2", d => d.target.x + 50)
            .attr("y2", d => d.target.y + 15);

        nodes
            .attr("x", d => d.x)
            .attr("y", d => d.y);

        labels
            .attr("x", d => d.x + 5)
            .attr("y", d => d.y + 20);
    });
}


    },
    mounted() {
        this.fetchNodes();
        this.fetchTypeOperators();
    }
});

</script>
</body>
</html>

