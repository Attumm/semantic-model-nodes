<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Selector with Vue</title>
    <script src="vue.js"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        svg {
            overflow: scroll;
        }

        .node {
            margin: 10px;
            border: 1px solid black;
            padding: 10px;
            display: inline-block;
            cursor: pointer;
        }

        .field {
            margin-top: 5px;
        }

        div.container {
            width: 100%;
            /* Or a fixed size like 800px */
            height: auto;
            overflow: scroll;
        }

        .context-menu {
            position: absolute;
            background-color: #f5f5f5;
            border: 1px solid #ccc;
            padding: 10px;
            box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            cursor: pointer;
        }


        /* d3.js workaround for text */
        text {
            pointer-events: none;
        }

        #app {
            position: relative;
            /* Important for positioning the row count */
            display: grid;
            grid-template-columns: 20% 1fr;
            /* left_panel takes 20%, center takes the remaining width */
            grid-template-rows: auto auto;
            /* Two rows: one for top and another for center */
            grid-template-areas:
                "left_panel center_top right_top"
                "left_panel center_center .";
        }

        .left_panel {
            grid-area: left_panel;
        }

        .center_top {
            grid-area: center_top;
        }

        .right_top {
            grid-area: right_top;
        }

        .center_center {
            grid-area: center_center;
        }

        /* For the row count */
        .row_count {
            position: absolute;
            top: 0;
            right: 0;
            padding: 24px;
            z-index: 10;
            /* To ensure it stays on top */
        }
    </style>
</head>

<body>
    <div id="app">
        <!-- Left Panel -->
        <div class="left_panel">
            <button @click="toggleLayout">Toggle Layout</button>
            <!-- Search input -->
            <input v-model="searchQuery" placeholder="Search for nodes..." />
            <h3>Available Nodes:</h3>
            
            <div v-for="node in filteredNodes" class="node" @click="setActiveNode(node)">
                {{ node }}
            </div>
        </div>

        <!-- Center Top Panel -->
        <div class="center_top">
            <svg width="20000" height="400" overflow="scroll"></svg>
        </div>

        <!-- Right Top Panel -->
        <!-- We'll keep this empty since the Row Count has its own separate section -->

        <!-- Center Center Panel -->
        <div class="center_center" style="width: 100%; overflow-x: auto; margin-top: 2em;">
            <h3 v-if="result && result.length">Results:</h3>
            <table v-if="result && result.length" border="1" cellspacing="0" cellpadding="5">
                <thead>
                    <tr>
                        <th v-for="header in Object.keys(result[0])">{{ header }}</th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-for="row in result">
                        <td v-for="value in Object.values(row)">{{ value }}</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Row Count -->
        <div class="row_count">
            Row Count: {{ current_row_count }}
        </div>
    </div>




    <!-- Some basic styles for visibility -->
    <style>
        .node {
            cursor: pointer;
            background-color: #e6e6e6;
            padding: 10px;
            margin: 5px;
        }
    </style>


    <script>
        new Vue({
            el: '#app',
            data: {

                layoutOrientation: 'horizontal',
                searchQuery: '',
                //layoutOrientation: 'vertical',
                nodesData: {}, // Loaded from API
                activeNode: null,
                current_row_count: "",
                type_operators: {},
                graph: {
                    nodes: [],
                    links: []
                },
                fieldOrder: [],
                result: {},
            },
            computed: {
                filteredNodes() {
                    // If there's no search query, return all nodes
                    if (!this.searchQuery) {
                        return Object.keys(this.nodesData);
                    }

                    // Convert search query to lowercase for case-insensitive search
                    const query = this.searchQuery.toLowerCase();

                    // Filter nodes based on the search query
                    return Object.keys(this.nodesData).filter(node => node.toLowerCase().includes(query));
                },

            },
            methods: {

                generateQueryString() {
                    // Construct the "dn" part of the string using activeNode's name
                    let queryString = "dn=" + encodeURIComponent(this.activeNode.name);

                    // Map the field nodes to the desired string format and sort by slot
                    let fieldStrings = this.graph.nodes
                        .filter(node => node.type === "field")
                        .sort((a, b) => a.slot - b.slot)
                        .map(field => `field=${encodeURIComponent(field.parent + '.' + field.name)}`);

                    // Filter the operator nodes that are of type "filter", sort by slot,
                    // and then map to the desired string format
                    let filterStrings = this.graph.nodes
                        .filter(node => node.type === "operator" && node.operator_type === "filter")
                        .sort((a, b) => a.slot - b.slot)
                        .map(filter =>
                            `filter=${encodeURIComponent(filter.operator + ':' + filter.parent + '.' + filter.field_name + ':' + filter.operator_input)}`
                            );

                    // If there are fieldStrings or filterStrings, prepend them with an "&"
                    if (fieldStrings.length > 0) {
                        queryString += "&" + fieldStrings.join("&");
                    }

                    if (filterStrings.length > 0) {
                        queryString += "&" + filterStrings.join("&");
                    }

                    return queryString;
                },

                generateQueryString1() {
                    // Construct the "dn" part of the string using activeNode's name
                    let queryString = "dn=" + this.activeNode.name;

                    // Map the field nodes to the desired string format and sort by slot
                    let fieldStrings = this.graph.nodes
                        .filter(node => node.type === "field")
                        .sort((a, b) => a.slot - b.slot)
                        .map(field => `field=${field.parent}.${field.name}`);

                    // Filter the operator nodes that are of type "filter", sort by slot,
                    // and then map to the desired string format
                    let filterStrings = this.graph.nodes
                        .filter(node => node.type === "operator" && node.operator_type === "filter")
                        .sort((a, b) => a.slot - b.slot)
                        .map(filter =>
                            `filter=${filter.operator}:${filter.parent}.${filter.field_name}:${filter.operator_input}`
                            );

                    // If there are fieldStrings or filterStrings, prepend them with an "&"
                    if (fieldStrings.length > 0) {
                        queryString += "&" + fieldStrings.join("&");
                    }

                    if (filterStrings.length > 0) {
                        queryString += "&" + filterStrings.join("&");
                    }
                    return queryString;
                },
                toggleLayout() {
                    console.log(this.generateQueryString())
                    this.fetchResults()
                    if (this.layoutOrientation === 'horizontal') {
                        this.layoutOrientation = 'vertical';
                    } else {
                        this.layoutOrientation = 'horizontal';
                    }

                    this.drawGraph();
                },
                fetchResults() {
                    fetch("api/gen/?" + this.generateQueryString())
                        .then(response => response.json())
                        .then(data => {
                            this.result = data;
                        });
                },
                fetchNodes() {
                    fetch("api/list-nodes?format=json&groupby=node")
                        .then(response => response.json())
                        .then(data => {
                            this.nodesData = data;
                        });
                },
                fetchTypeOperators() {
                    fetch("api/sm-query-options/")
                        .then(response => response.json())
                        .then(data => {
                            this.type_operators = data["type_operators"];
                        });
                },
                findNodeAndSetRowCount(node) {
                    let foundNode = null;

                    // Loop over  keys in the nodesData object
                    for (let key in this.nodesData) {
                        // Find the node within the current array
                        foundNode = this.nodesData[key].find(entry => entry.node === node);

                        // If the node is found, break out of the loop for efficiency
                        if (foundNode) {
                            break;
                        }
                    }

                    // If the node was found in the nested arrays, update the current_row_count
                    if (foundNode) {
                        this.current_row_count = foundNode.row_count;
                    }
                },

                setActiveNode(node) {
                    this.findNodeAndSetRowCount(node);
                    this.graph.nodes = [];
                    this.graph.links = [];

                    // Create central node for the selected node
                    this.activeNode = {
                        type: 'node',
                        name: node,
                        slot: 1,
                        level: 0
                    };

                    this.graph.nodes.push(this.activeNode);

                    // Use fieldOrder to add fields to graph.nodes with type 'field'
                    this.nodesData[node].forEach((field, index) => {
                        const fieldNode = {
                            type: 'field',
                            name: field.field,
                            slot: index,
                            level: 1,
                            parent: field.node,
                            field_type: field.field_type
                        };

                        this.graph.nodes.push(fieldNode);
                        this.graph.links.push({
                            source: this.activeNode,
                            target: fieldNode
                        });
                    });
                    this.drawGraph();




                },
                drawGraph() {
                    const svg = d3.select("svg");
                    svg.selectAll("*").remove();

                    // Define grid levels
                    const slotWidth = 150;
                    const slotHeight = 100;
                    const gridY_level = [50, 150, 250];
                    const gridXSpacing = 100;

                    this.graph.nodes.forEach(node => {
                        node.fx = node.slot * slotWidth;
                        node.fy = gridY_level[node.level];
                    })


                    const simulation = d3.forceSimulation(this.graph.nodes)
                        .force("link", d3.forceLink(this.graph.links).id(d => d.id).distance(80))
                        .force("charge", d3.forceManyBody().strength(-1000))
                        .force("center", d3.forceCenter(400, 200));

                    const links = svg.append("g")
                        .selectAll("line")
                        .data(this.graph.links)
                        .enter().append("line")
                        .attr("stroke", "#999")
                        .attr("stroke-opacity", 0.6);

                    const nodes = svg.append("g")
                        .selectAll("rect")
                        .data(this.graph.nodes)
                        .enter().append("rect")
                        .attr("width", 120)
                        .attr("height", 30)
                        .attr("rx", 10)
                        .attr("ry", 10)
                        .attr("fill", d => {
                            if (d.type === 'node') return "#69a3b2";
                            if (d.type === 'field') return "#d1c4e9";
                            if (d.type === 'operator') return "#d4af37"; // Adjusted color for operator
                            if (d.type === 'link') return "#c15c22"; // Adjusted color for link
                            return "gray"; // Default color in case none of the types matc

                        }).attr("x", d => d.fx - 50) // Half the width to center
                        .attr("y", d => d.fy - 15) // Half the height to center
                        .call(d3.drag()
                            .on("start", dragstarted.bind(this))
                            .on("drag", dragged.bind(this))
                            .on("end", dragended.bind(this)))
                        .on('click', (event, d) => {
                            if (d.type === 'field') {
                                createContextMenu(event, d);
                            }
                        });

                    const labels = svg.append("g")
                        .selectAll("text")
                        .data(this.graph.nodes)
                        .enter().append("text")
                        .attr("font-size", "16px")
                        .text(d => d.name)
                        .attr("text-anchor", "right")
                        .attr("x", d => d.fx)
                        .attr("y", d => d.fy)

                    function dragstarted(event, d) {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        intendedY = d.fy = d.y;
                    }

                    function dragged(event, d) {
                        d.fx = event.x;
                        d.fy = gridY_level[d.level]; // Always lock the y-position based on the level

                        const newSlot = Math.round(d.fx / slotWidth);

                        // Check if there's any other node in this newSlot
                        const nodeInNewSlot = this.graph.nodes.find(node => node.slot === newSlot && node
                            .level === d.level && node !== d);

                        if (nodeInNewSlot) {
                            // Swap their slots
                            nodeInNewSlot.slot = d.slot;
                            d.slot = newSlot;

                            // Update their fixed x-positions based on the updated slot positions
                            nodeInNewSlot.fx = nodeInNewSlot.slot * slotWidth;
                            d.fx = d.slot * slotWidth;
                        }
                    }

                    function dragended(event, d) {
                        if (!event.active) simulation.alphaTarget(0);

                        // Update slot based on final position
                        const newSlot = Math.round(d.fx / slotWidth);
                        d.slot = newSlot;

                        // Set the fixed position based on slot and level
                        d.fx = d.slot * slotWidth;
                        //d.fy = null
                        //Y_level[d.level];
                    }

                    function removeNode(nodeData, event) {
                        console.log(event)
                        console.log(this)

                        // Capture the slot of the node to be removed
                        const removedNodeSlot = nodeData.slot;

                        // Remove the node from graph.nodes
                        const nodeIndex = this.graph.nodes.indexOf(nodeData);
                        if (nodeIndex > -1) {
                            this.graph.nodes.splice(nodeIndex, 1);
                        }

                        const linksToRemove = this.graph.links.filter(link => {
                            return link.source === nodeData || link.target === nodeData;
                        });


                        const operatorNodesToRemove = [];

                        linksToRemove.forEach(link => {
                            // Store the operator nodes that are associated with these links for removal
                            if (link.source.type === 'operator' && operatorNodesToRemove.indexOf(link
                                    .source) === -1) {
                                operatorNodesToRemove.push(link.source);
                            } else if (link.target.type === 'operator' && operatorNodesToRemove.indexOf(
                                    link.target) === -1) {
                                operatorNodesToRemove.push(link.target);
                            }

                            // Remove the link itself
                            const linkIndex = this.graph.links.indexOf(link);
                            if (linkIndex > -1) {
                                this.graph.links.splice(linkIndex, 1);
                            }
                        });

                        // Now, let's remove the operator nodes that were linked to the nodeData
                        operatorNodesToRemove.forEach(operatorNode => {
                            const nodeIndex = this.graph.nodes.indexOf(operatorNode);
                            if (nodeIndex > -1) {
                                this.graph.nodes.splice(nodeIndex, 1);
                            }
                        });


                        // Adjust the slot values of all nodes that come after the removed node
                        this.graph.nodes.forEach(node => {
                            if (node.type === "field" && node.slot > removedNodeSlot) {
                                node.slot -= 1;
                            }
                        });

                        // Let the drawing function handle positioning and rendering
                        this.drawGraph();
                    }

                    function openOperatorDialog(nodeData, event) {
                        const div = document.createElement('div');
                        const currentContext = this;

                        div.style.position = 'absolute';
                        div.style.left = `${event.pageX}px`;
                        div.style.top = `${event.pageY}px`;
                        div.style.zIndex = '1000';

                        const optionsArray = this.type_operators[nodeData["field_type"]];
                        console.log(nodeData["field_type"])
                        let optionsHTML = optionsArray.map(option =>
                            `<option value="${option}">${option}</option>`).join('');

                        div.innerHTML = `
        <label>Operator Type:</label>
        <select id="operatorOption">${optionsHTML}</select>
        
        <label>Enter Operator Details:</label>
        <input type="text" id="operatorInput" />
        
        <button onclick="submitHandler()">OK</button>
    `;

                        document.body.appendChild(div);

                        const submitHandler = () => {
                            const selectedOption = document.getElementById('operatorOption').value;
                            const inputValue = document.getElementById('operatorInput').value;

                            const slotIsTaken = currentContext.graph.nodes.some(node => node.slot ===
                                nodeData.slot && node.type === 'operator');
                            if (slotIsTaken) {
                                currentContext.graph.nodes.forEach(node => {
                                    if (node.slot >= nodeData.slot && node.type === 'operator') {
                                        node.slot += 1;
                                    }
                                });
                            }
                            if (inputValue) {
                                const operatorNode = {
                                    type: 'operator',
                                    name: selectedOption + ": " + inputValue,
                                    slot: nodeData.slot,
                                    level: 2,
                                    parent: nodeData.parent,
                                    field_name: nodeData.name,
                                    operator_type: "filter",
                                    operator: selectedOption,
                                    operator_input: inputValue
                                };

                                currentContext.graph.nodes.push(operatorNode);
                                currentContext.graph.links.push({
                                    source: nodeData,
                                    target: operatorNode
                                });

                                currentContext.drawGraph();
                            }

                            document.body.removeChild(div);
                        };

                        window.submitHandler = submitHandler;
                    }


                    function openLinkDialog(nodeData) {
                        const div = document.createElement('div');
                        div.innerHTML = `
        <label>Enter Link Details:</label>
        <input type="text" id="linkInput" />
        <button onclick="handleLinkSubmit()">OK</button>
    `;

                        document.body.appendChild(div);

                        // Define the handler for when the dialog is submitted
                        window.handleLinkSubmit = function () {
                            const inputValue = document.getElementById('linkInput').value;
                            if (inputValue) {
                                // Make the API call or any other logic you need with the inputValue
                                // Example: createLink(nodeData, inputValue);
                            }
                            // Remove the dialog after submission
                            document.body.removeChild(div);
                        }
                    }

                    function handleContextMenuClick(option, nodeData, event) {
                        console.log(this)
                        switch (option) {
                            case 'Remove':
                                console.log("remove")
                                removeNode(nodeData, event);
                                break;
                            case 'Operator':
                                console.log("operator")
                                openOperatorDialog(nodeData, event);
                                break;
                            case 'Link':
                                console.log("link")
                                openLinkDialog(nodeData, event);
                                break;
                        }
                    }

                    function createContextMenu(event, d) {
                        // Remove any existing context menu
                        d3.selectAll('.context-menu').remove();

                        // Create a div for our context menu
                        const menu = d3.select('body')
                            .append('div')
                            .attr('class', 'context-menu')
                            .style('left',
                            `${event.pageX + 10}px`) // slight offset to not directly open under mouse
                            .style('top', `${event.pageY + 10}px`)
                            .style('zIndex', '1000')
                            .style('border', '1px solid #ccc') // Border around the context menu
                            .style('border-radius', '4px') // Rounded corners
                            .style('background-color', '#f5f5f5') // Background color
                            .style('font-family', 'Arial, sans-serif') // Font 
                            .style('box-shadow', '3px 3px 10px rgba(0, 0, 0, 0.2)'); // Drop shadow

                        const options = ['Remove', 'Operator', 'Link'];

                        // Append our three options to the menu
                        menu.selectAll('p')
                            .data(options)
                            .enter()
                            .append('p')
                            .text(d => d)
                            .style('margin', '0') // Remove margin
                            .style('padding', '10px 15px') // Padding for each option
                            .style('cursor', 'pointer') // Hand cursor on hover
                            .on('mouseover', function () {
                                d3.select(this).style('background-color',
                                '#e5e5e5'); // Change background color on hover
                            })
                            .on('mouseout', function () {
                                d3.select(this).style('background-color',
                                '#f5f5f5'); // Reset background color
                            })
                            .on('click', function (event) {
                                const selectedOption = d3.select(this).text();
                                handleContextMenuClick(selectedOption, d, event);
                                d3.selectAll('.context-menu').remove();
                            });
                    }


                    removeNode = removeNode.bind(this);
                    openLinkDialog = openLinkDialog.bind(this)
                    openOperatorDialog = openOperatorDialog.bind(this)
                    handleContextMenuClick = handleContextMenuClick.bind(this);
                    createContextMenu = createContextMenu.bind(this);


                    simulation.on("tick", () => {
                        links
                            .attr("x1", d => d.source.x + 50)
                            .attr("y1", d => d.source.y + 15)
                            .attr("x2", d => d.target.x + 50)
                            .attr("y2", d => d.target.y + 15);

                        nodes
                            .attr("x", d => d.x)
                            .attr("y", d => d.y);

                        labels
                            .attr("x", d => d.x + 5)
                            .attr("y", d => d.y + 20);
                    });
                }


            },
            mounted() {
                this.fetchNodes();
                this.fetchTypeOperators();
            }
        });
    </script>
</body>

</html>